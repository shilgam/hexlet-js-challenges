# Content

Course: https://ru.hexlet.io/courses/js_prototypes

В JS реализация ООП сильно отличается от многих подобных ЯП (java, ruby, python, ...).
JS больше соответствует классическому пониманию ООП, сформулированному Аланом Кеем.

В этом курсе познакомимся с этой моделью и научимся с ней работать.
Она основана на прототипах.

Показать все что скрыто:
* в языке нет классов
* класс это функция
* функция это обьект
* `this` не текущий объект

Основные темы:
* Иерархии типов
* Наследование
* Прототипы
* Позднее связывание

Дополнительные темы:
* Парсинг
* Абстрактное синтаксическое дерево

Проект
* Парсинг DSL

Сначала рекомендуем пройти курс: "JS: Коллекции"

## Lesson 3: Абстрактное синтаксическое дерево (AST)

Недостатки текущего решения (data --> html):
1. Исх. структура оптимизизована для написания, НО необходимо выполнять кучу проверок
2. Неудобное представление для обратного преобразования (html --> data)

**AST** - Дерево, использующееся для промежуточного представления исходных данных.

Преимущества AST:
1. Проще добавлять новые представления
2. Проще анализировать
3. Разделяй и влавствуй (про вынесение парсинга)

## Lesson 4: Полиморфизм подтипов
## Lesson 5: Иерерхия типов

__Классификация__ - осмысленный порядок вещей, явлений, разделение их на рановидности согласно каким-либо важным признакам.

Цели классификации:
* систематизация
* обобщение, ...

Пример классификации - Иерархия типов (from SICP)
* _Комплексные:_ -2 + √2i
* _Действительные:_ √2, √3, 4
* _Рациональные:_ 1/2, -5/3, 5
* _Целые:_ 1, 2, -5

Характеристики иерерхии типов:
* Отношение: Частный тип(Integer) - Общий тип (Rational)
* Подтипы "наследуют" поведение надтипов
* В операциях работающих с надтипами, всегда можно использовать подтип (после приведения)

__Наследование__ один из способов реализации иерархии типов:
```
Целые  <  Рациональные  <  Действительные
подтип        тип             надтип
```

__Принцип Лисков__ (SOLID) по Фаулеру:
* Функции, использующие базовый тип, должны иметь возможность использовать подтипы базового класса, не зная об этом.

ИЛИ:
* Предусловия не могут быть усилены в подклассе.
* Постусловия не могут быть ослаблены в подклассе.

Зачем?
* Системы типов не могут гарантировать корректность иерархии
*  Некорректное использование наследования может приводить к ошибкам
* Снижается модульность (текут абстракции)

Иерархия типов не всегда является деревьями (Множественное наследование):
<img align="left" width="400" src="https://user-images.githubusercontent.com/18242773/32147609-3801f174-bcfb-11e7-8e5a-68b16227c534.png">

Реальность:
* Множественные надтипы - боль
* Очень легко ошибиться
* Композиция вместо наследования
