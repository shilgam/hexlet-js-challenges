
## Задание:

### Order.js

Реализуйте и экспортируйте по умолчанию тип `Order`. Сделайте так чтобы на каждое изменение состояния в массив `history` добавлялась запись об этом в виде `{ state: <name>, createdAt: new Date() }`. Используйте для этого событие `onEnterState` библиотеки `javascript-state-machine`.

Эта библиотека неявно проставляет состояние `'none'` и делает переход в начальный стейт (в нашем случае - `'init'`). Нас эти состояния не интересуют, поэтому в `'history'` их нужно избегать.

Реализуйте конечный автомат процесса заказа товаров в магазине:

Начальное состояние: `init`. Событие `accept` переводит автомат в `pending` (только из `init`). Событие `ship` переводит в состояние `shipped` (только из `pending`). Событие `complete` переводит в состояние `completed` (только из `shipped`). Событие `cancel` переводит в состояние `canceled` (только из состояний `init` и `pending`) Событие `refund` переводит в состояние `refunded` (только из состояний `shipped` и `completed`)

Немного пояснения. Отменить заказ можно только до тех пор пока он не был отправлен клиенту. Если заказ уже был отправлен или доставлен, то клиент может сделать возврат. В реальной жизни на эти переходы будут происходить дополнительные действия связанные с обработкой платежа, отправки почты и тому подобное.

### solution.js

Реализуйте обработчик (функцию) `cancel` который генерирует на автомате аналогичные события в случае если их возможно применить.

Это задание подразумевает то, что хорошо изучите документацию библиотеки.
Все как в реальной жизни ;)

### Подсказки

State Machine Factory:
https://github.com/jakesgordon/javascript-state-machine/blob/master/docs/state-machine-factory.md


## THEORY:

Паттерн State настоящее спасение во многих ситуациях, но и он не совершенен. Главная проблема этого подхода в том, что логика переходов разбросана по всему коду, и сами состояния знают о том, когда и в какое состояние нужно перевести автомат. При достаточно большом автомате это становится проблемой.

Решением является выделение таблицы переходов. Делать это можно как и в рамках паттерна `State`, плавно доводя его до паттерна `State Machine`, либо с использованием специальных библиотек, которые водятся в изобилии для каждого языка программирования.
```js
const fsm = {
  initial: 'draft',
  transitions: [
    { name: 'sendToModerate', from: ['draft', 'declined'], to: 'moderating' },
    { name: 'accept', from: 'moderating', to: 'published' },
    { name: 'decline', from: ['moderating', 'published'], to: 'declined' },
  ],
};
```

Я, надеюсь, что такая форма (декларативная) говорит сама за себя. Описанный здесь процесс похож на то, как работает публикация статей на Хабре.

Переходы в `fsm` осуществляются __только__ посредством порождения событий. Это настолько важно, что я вынужден повторить. При использовании конечных автоматов состояния не могут меняться напрямую, такой подход уничтожает весь смысл использования автоматов. Именно переходы между состояниями являются значимыми в таких системах и программируются разработчиком.

### javascript-state-machine
Рассмотрим самую популярную на гитхабе библиотеку для работы с автоматами в js:
https://github.com/jakesgordon/javascript-state-machine

```js
import StateMachine from 'javascript-state-machine';

const fsm = new StateMachine({
  initial: 'green',
  transitions: [
    { name: 'warn',  from: 'green',  to: 'yellow' },
    { name: 'panic', from: 'yellow', to: 'red'    },
    { name: 'calm',  from: 'red',    to: 'yellow' },
    { name: 'clear', from: 'yellow', to: 'green'  },
]});

fsm.current; // green
fsm.warn();
fsm.is('yellow'); // true
fsm.can('calm'); // false

fsm.calm(); // throw error
```

1. Таблица отражает логику процесса. В своей повседневной практике, первое, на что я смотрю в коде, это автоматы, реализованные в сущностях. По ним можно понять, какие основные процессы происходят в программе и как они концептуально работают.
2. Подобные библиотеки, обычно, автоматически генерируют код для работы автомата и самостоятельно проверяют его корректность, не позволяя случаться неправильным переходам. Это огромный плюс перед ручным кодированием.
3. Также эти библиотеки предоставляют возможность реагировать на события и переходы.

### Коллбеки

```js
const fsm = new StateMachine({
  initial: 'green',
  transitions: [/* ... */],
  methods: {
    onGreen: ({ transition, from, to }) => { /*...*/ },
    onBeforeWarn: (lifecycle) => { /*...*/ },
    onLeaveRed: ({ transition, from, to }) => { /*...*/ },
  }
});

fsm.calm('message');
```

Обратите внимание на то, что автомат не всегда подразумевает разное поведение всех подсистем в зависимости от того, в каком он состоянии. Часто, в реальном коде, важен сам факт того, что сущность находится в каком-то состоянии и может переходить в другое. Даже в этом случае имеет смысл явно выделять автомат и пользоваться всей прелестью автоматической генерации и верификации. Набрав определенный опыт, вы будете использовать автоматы повсеместно, даже в случаях когда состояний всего два и, казалось бы, можно просто использовать флаг. На самом деле даже с флагом у вас появится логика, которую мог бы обеспечить автомат. К слову, в Хекслете используется около 80 явных автоматов (на момент написания урока).
