# Content

Course: https://ru.hexlet.io/courses/js-abp

## Lesson 1: Intro

About:
* Состояние
* Конечные автоматы
* Диаграмма состояний (UML)
* Библиотеки для описания автоматов
* Шаблоны проектирования (State, State Machine)

Термин "Парадигма программирования" > Томас Кун «Структура научных революций»

## Lesson 2: Легкость и виды сложности

"Сложный" — это состоящий из большого числа элементов, взаимодействующих друг с другом.

Причем, чем больше этого взаимодействия и чем более оно разнообразно, тем более сложная на выходе система.

"Простой-сложный" — это объективная оценка системы или модели.

 Легкий-тяжелый" - субъективная оценка.

 ```
 Simple           | Complex       
------------------|---------------
 Constant         | Variable      
 Data             | Object (Hard)
 Recursion (Hard) | Loop          
 ```

__2 типа сложности:__
* Необходимая сложность -- Определяется сложностью решаемой проблемы/предметной области.
* Случайная сложность -- Определяется проблемами, которые создают сами программисты, например, используют неправильные инструменты для данной задачи.

__Lang:__ haskell, clojure, prolog, erlang, kotlin, c.

## Lesson 3: Конечный автомат

Def: __Конечный автомат__ - Модель, с помощью которой удобно представлять процесс, имеющий конечное число дискретных управляющих состояний

"Состояние программы" - это, грубо говоря, слепок её памяти.

Состояние можно поделить на два __типа__:
* __Управляющие состояние__	— отвечающее за все возможные пути движения данных сквозь программу
* __Вычислительные состояние__ — это данные сами по себе


## Lesson 4: Лексический анализ

__Задача:__ Необходимо во входящем тексте сделать заглавной первую букву каждого слова.

Как решил бы "обычный программист":
```js
export default (str) => {
  let result = '';
  for (let i = 0; i < str.length; i++) {
    const shouldBeBig = str[i] !== ' ' && (i === 0 || str[i - 1] === ' ');
    result += shouldBeBig ? str[i].toUpperCase() : str[i];
  }

  return result;
};
```

Как решил бы "автоматный программист":

```js
export default (str) => {
  let result = '';
  let state = 'outside'; // outside, inside
  for (let i = 0; i < str.length; i++) {
    switch (state) {
      case 'inside':
        if (str[i] === ' ') {
          state = 'outside';
        }
        result += str[i];
        break;
      case 'outside':
        if (str[i] !== ' ') {
          result += str[i].toUpperCase();
          state = 'inside';
        } else {
          result += str[i];
        }
        break;
    }
  }
  return result;
};
```
